n_total  = n(),
n_removed = sum(!keep),
pct_removed = 100 * n_removed / n_total,
.groups = "drop"
)
# ----------------------------
# 3) Plot: overall across designated clusters
# ----------------------------
p_overall <- ggplot(summ_all, aes(x = method, y = pct_removed, fill = method)) +
geom_col(width = 0.7, alpha = 0.95) +
geom_text(aes(label = paste0(sprintf("%.1f", pct_removed), "%\n(",
n_removed, "/", n_total, ")"),
y = pct_removed + 0.02 * max(pct_removed, na.rm = TRUE)),
size = 3.4, vjust = 0) +
labs(x = NULL, y = "Removed cells (%)",
title = "Percent of removed cells by method",
subtitle = paste("Designated cluster(s):", paste(target_chr, collapse = ", "))) +
theme_classic(base_size = 12) +
theme(legend.position = "none",
axis.text.x = element_text(angle = 10, hjust = 1))
print(p_overall)
if (isTRUE(by_cluster)) {
p_byclus <- ggplot(summ_by_cluster, aes(x = method, y = pct_removed, fill = method)) +
geom_col(width = 0.7, alpha = 0.95) +
geom_text(aes(label = paste0(sprintf("%.1f", pct_removed), "%\n(",
n_removed, "/", n_total, ")"),
y = pct_removed + 0.02 * max(pct_removed, na.rm = TRUE)),
size = 3.1, vjust = 0) +
facet_wrap(~ cluster, nrow = 1) +
labs(x = NULL, y = "Removed cells (%)",
title = "Percent of removed cells by method (per cluster)") +
theme_classic(base_size = 12) +
theme(legend.position = "none",
strip.background = element_blank(),
strip.text = element_text(face = "bold"),
axis.text.x = element_text(angle = 10, hjust = 1))
print(p_byclus)
}
suppressPackageStartupMessages({
library(Seurat); library(dplyr); library(tidyr); library(ggplot2); library(tibble); library(forcats)
})
# ----------------------------
# 0) Choose your cluster(s)
# ----------------------------
if ("seurat_clusters" %in% colnames(seu@meta.data)) Idents(seu) <- "seurat_clusters"
target_clusters <- c(0,1)  # EDIT as needed
ident_vec  <- as.character(Idents(seu))
target_chr <- as.character(target_clusters)
cells_cluster <- colnames(seu)[ident_vec %in% target_chr]
if (length(cells_cluster) == 0L) stop("No cells matched target_clusters. Check Idents(seu) and cluster labels.")
# ----------------------------
# 1) Collect available QC methods (keep_* columns)
# ----------------------------
keep_cols <- c("keep_seurat","keep_scater","keep_miQC","keep_enrich")
keep_cols <- keep_cols[keep_cols %in% colnames(seu@meta.data)]
if (length(keep_cols) == 0L) stop("No keep_* columns found.")
# coerce to logical
for (k in keep_cols) seu@meta.data[[k]] <- as.logical(seu@meta.data[[k]])
method_map <- c(keep_seurat = "Seurat",
keep_scater = "scater",
keep_miQC   = "miQC",
keep_enrich = "scQCenrich")
# ----------------------------
# 2) Compute removal statistics
# ----------------------------
meta <- seu@meta.data %>% rownames_to_column("cell")
calc_one <- function(col) {
mname <- method_map[[col]]
x <- meta %>% select(cell, keep = all_of(col)) %>% mutate(removed = !keep)
# Whole sample
n_tot_all  <- nrow(x)
n_rem_all  <- sum(x$removed, na.rm = TRUE)
pct_rem_all <- 100 * n_rem_all / n_tot_all
# Cluster subset
xc <- x %>% filter(cell %in% cells_cluster)
n_tot_clu  <- nrow(xc)
n_rem_clu  <- sum(xc$removed, na.rm = TRUE)
pct_rem_clu <- 100 * if (n_tot_clu > 0) n_rem_clu / n_tot_clu else NA_real_
# Share of removed that come from the cluster (of all removed in sample)
share_clu_of_removed <- if (n_rem_all > 0) 100 * n_rem_clu / n_rem_all else NA_real_
tibble(
method = mname,
pct_removed_cluster = pct_rem_clu,
pct_removed_sample  = pct_rem_all,
share_removed_from_cluster = share_clu_of_removed,
n_cluster = n_tot_clu,
n_sample  = n_tot_all,
n_removed_cluster = n_rem_clu,
n_removed_sample  = n_rem_all
)
}
stats <- bind_rows(lapply(keep_cols, calc_one)) %>%
mutate(method = factor(method, levels = c("Seurat","scater","miQC","scQCenrich")[c("keep_seurat","keep_scater","keep_miQC","keep_enrich") %in% keep_cols]))
# Long for plotting the two rates
plot_df <- stats %>%
select(method, pct_removed_cluster, pct_removed_sample) %>%
pivot_longer(-method, names_to = "where", values_to = "percent_removed") %>%
mutate(where = recode(where,
pct_removed_cluster = "Cluster (within cluster)",
pct_removed_sample  = "Whole sample (global)"))
# ----------------------------
# 3) Plot: % removed (cluster vs whole) with share labels
# ----------------------------
p <- ggplot(plot_df, aes(x = method, y = percent_removed, fill = where)) +
geom_col(position = position_dodge(width = 0.72), width = 0.68, alpha = 0.95) +
geom_text(
data = stats,
aes(x = method,
y = pmax(pct_removed_cluster, pct_removed_sample, na.rm = TRUE) * 1.05,
label = ifelse(is.finite(share_removed_from_cluster),
paste0("cluster share of removed = ", sprintf("%.1f%%", share_removed_from_cluster)),
"cluster share of removed = NA")),
inherit.aes = FALSE, size = 3.4, vjust = 0
) +
scale_y_continuous(expand = expansion(mult = c(0.02, 0.18))) +
labs(x = NULL, y = "Removed cells (%)",
title = "Removal rate by method: cluster vs whole sample",
subtitle = paste0("Designated clusters: ", paste(target_chr, collapse = ", ")),
fill = NULL) +
theme_classic(base_size = 12) +
theme(legend.position = "top",
axis.text.x = element_text(angle = 10, hjust = 1))
print(p)
# ggsave("removed_rate_cluster_vs_sample_by_method.png", p, width = 9.5, height = 4.0, dpi = 200)
# ----------------------------
# 4) (Optional) also show a pure ratio bar: (removed in cluster) / (removed in sample)
# ----------------------------
ratio_df <- stats %>%
transmute(method, ratio = ifelse(n_removed_sample > 0, n_removed_cluster / n_removed_sample, NA_real_))
p_ratio <- ggplot(ratio_df, aes(method, 100 * ratio, fill = method)) +
geom_col(width = 0.6, alpha = 0.95, show.legend = FALSE) +
geom_text(aes(label = paste0(sprintf("%.1f", 100 * ratio), "%")),
vjust = -0.2, size = 3.6) +
scale_y_continuous(labels = function(z) paste0(z, "%"),
expand = expansion(mult = c(0.02, 0.12))) +
labs(x = NULL, y = "Share of removed coming from cluster (%)",
title = "Cluster contribution to removed cells by method",
subtitle = paste0("Designated clusters: ", paste(target_chr, collapse = ", "))) +
theme_classic(base_size = 12)
# print(p_ratio)  # uncomment to view
# ggsave("removed_share_from_cluster_by_method.png", p_ratio, width = 7.5, height = 4.0, dpi = 200)
suppressPackageStartupMessages({
library(Seurat); library(dplyr); library(tidyr); library(ggplot2); library(tibble); library(forcats)
library(ggpubr)
})
# ----------------------------
# 0) Choose your cluster(s)
# ----------------------------
if ("seurat_clusters" %in% colnames(seu@meta.data)) Idents(seu) <- "seurat_clusters"
target_clusters <- c(1,2)  # <-- edit your designated cluster(s)
ident_vec  <- as.character(Idents(seu))
target_chr <- as.character(target_clusters)
cells_cluster <- colnames(seu)[ident_vec %in% target_chr]
if (length(cells_cluster) == 0L) stop("No cells matched target_clusters. Check Idents(seu) and cluster labels.")
# ----------------------------
# 1) Available methods (keep_* cols)
# ----------------------------
keep_cols <- c("keep_seurat","keep_scater","keep_miQC","keep_enrich")
keep_cols <- keep_cols[keep_cols %in% colnames(seu@meta.data)]
if (length(keep_cols) == 0L) stop("No keep_* columns found.")
# coerce logical
for (k in keep_cols) seu@meta.data[[k]] <- as.logical(seu@meta.data[[k]])
method_map <- c(keep_seurat = "Seurat",
keep_scater = "scater",
keep_miQC   = "miQC",
keep_enrich = "scQCenrich")
# ----------------------------
# 2) Compute ratio: removed_in_cluster / removed_in_sample
#    + binomial 95% CI
# ----------------------------
meta <- seu@meta.data %>% rownames_to_column("cell")
calc_one <- function(col) {
mname <- method_map[[col]]
x <- meta %>% select(cell, keep = all_of(col)) %>% mutate(removed = !keep)
n_removed_sample  <- sum(x$removed, na.rm = TRUE)
if (n_removed_sample == 0) {
return(tibble(
method = mname,
x_cluster = NA_integer_, n_removed_sample = 0,
ratio = NA_real_, ci_low = NA_real_, ci_high = NA_real_
))
}
x_cluster <- x %>% filter(cell %in% cells_cluster) %>% summarise(n = sum(removed, na.rm = TRUE)) %>% pull(n)
# Binomial CI for proportion of removed that are from cluster
bt <- binom.test(x = x_cluster, n = n_removed_sample)
tibble(
method = mname,
x_cluster = x_cluster,
n_removed_sample = n_removed_sample,
ratio   = 100 * x_cluster / n_removed_sample,
ci_low  = 100 * bt$conf.int[1],
ci_high = 100 * bt$conf.int[2]
)
}
stats <- bind_rows(lapply(keep_cols, calc_one)) %>%
mutate(method = factor(method, levels = c("Seurat","scater","miQC","scQCenrich")[c("keep_seurat","keep_scater","keep_miQC","keep_enrich") %in% keep_cols]))
# safety: need scQCenrich for comparisons
if (!("scQCenrich" %in% as.character(stats$method))) {
warning("keep_enrich/scQCenrich not found; p-value comparisons will be skipped.")
}
# ----------------------------
# 3) Pairwise comparisons: scQCenrich vs each other method (prop.test)
# ----------------------------
p_df <- NULL
if ("scQCenrich" %in% as.character(stats$method)) {
sc_row <- stats %>% filter(method == "scQCenrich") %>% slice(1)
others <- stats %>% filter(method != "scQCenrich")
p_df <- others %>%
rowwise() %>%
do({
m <- .
# Build 2x2: [cluster removed / not-cluster removed] for each method
x1 <- sc_row$x_cluster
n1 <- sc_row$n_removed_sample
x2 <- m$x_cluster
n2 <- m$n_removed_sample
if (any(is.na(c(x1, n1, x2, n2))) || any(c(n1, n2) == 0)) {
data.frame(method = m$method, p = NA_real_)
} else {
p <- suppressWarnings(prop.test(x = c(x1, x2), n = c(n1, n2))$p.value)
data.frame(method = m$method, p = p)
}
}) %>%
ungroup() %>%
mutate(p.label = dplyr::case_when(
is.na(p) ~ "ns",
p < 1e-4 ~ "****",
p < 1e-3 ~ "***",
p < 1e-2 ~ "**",
p < 0.05 ~ "*",
TRUE     ~ "ns"
),
group1 = "scQCenrich",
group2 = method)
}
# y positions for brackets (just above the larger of the two bars)
if (!is.null(p_df) && nrow(p_df)) {
y_pos <- stats %>%
filter(method %in% c("scQCenrich", as.character(p_df$method))) %>%
select(method, top = ratio) %>%
tidyr::pivot_wider(names_from = method, values_from = top)
p_df <- p_df %>%
rowwise() %>%
mutate(y.position = 1.05 * max(stats$ratio[stats$method %in% c("scQCenrich", method)], na.rm = TRUE)) %>%
ungroup()
}
# ----------------------------
# 4) Plot: ratio (%) with 95% binomial CI; stars vs scQCenrich
# ----------------------------
p <- ggplot(stats, aes(x = method, y = ratio, fill = method)) +
geom_col(width = 0.65, alpha = 0.95, show.legend = FALSE) +
geom_errorbar(aes(ymin = ci_low, ymax = ci_high), width = 0.16) +
geom_text(aes(label = ifelse(is.finite(ratio),
paste0(sprintf("%.1f", ratio), "%"), "NA")),
vjust = -0.35, size = 3.5) +
scale_y_continuous(labels = function(z) paste0(z, "%"),
expand = expansion(mult = c(0.02, 0.18))) +
labs(x = NULL, y = "Removed in cluster / all removed (%)",
title = "Selectivity of removal for designated cluster",
subtitle = paste0("Clusters: ", paste(target_chr, collapse = ", "))) +
theme_classic(base_size = 12) +
theme(axis.text.x = element_text(angle = 10, hjust = 1))
if (!is.null(p_df) && nrow(p_df) && any(is.finite(p_df$y.position))) {
p <- p + ggpubr::stat_pvalue_manual(
p_df %>% filter(is.finite(y.position)),
label = "p.label",
xmin  = "group1",
xmax  = "group2",
y.position = "y.position",
tip.length = 0.01,
bracket.size = 0.4,
step.increase = 0.05,
inherit.aes = FALSE
)
}
print(p)
suppressPackageStartupMessages({
library(Seurat); library(dplyr); library(tidyr); library(ggplot2); library(tibble); library(forcats)
library(ggpubr)
})
# ----------------------------
# 0) Choose your cluster(s)
# ----------------------------
if ("seurat_clusters" %in% colnames(seu@meta.data)) Idents(seu) <- "seurat_clusters"
target_clusters <- c(1)  # <-- edit your designated cluster(s)
ident_vec  <- as.character(Idents(seu))
target_chr <- as.character(target_clusters)
cells_cluster <- colnames(seu)[ident_vec %in% target_chr]
if (length(cells_cluster) == 0L) stop("No cells matched target_clusters. Check Idents(seu) and cluster labels.")
# ----------------------------
# 1) Available methods (keep_* cols)
# ----------------------------
keep_cols <- c("keep_seurat","keep_scater","keep_miQC","keep_enrich")
keep_cols <- keep_cols[keep_cols %in% colnames(seu@meta.data)]
if (length(keep_cols) == 0L) stop("No keep_* columns found.")
# coerce logical
for (k in keep_cols) seu@meta.data[[k]] <- as.logical(seu@meta.data[[k]])
method_map <- c(keep_seurat = "Seurat",
keep_scater = "scater",
keep_miQC   = "miQC",
keep_enrich = "scQCenrich")
# ----------------------------
# 2) Compute ratio: removed_in_cluster / removed_in_sample
#    + binomial 95% CI
# ----------------------------
meta <- seu@meta.data %>% rownames_to_column("cell")
calc_one <- function(col) {
mname <- method_map[[col]]
x <- meta %>% select(cell, keep = all_of(col)) %>% mutate(removed = !keep)
n_removed_sample  <- sum(x$removed, na.rm = TRUE)
if (n_removed_sample == 0) {
return(tibble(
method = mname,
x_cluster = NA_integer_, n_removed_sample = 0,
ratio = NA_real_, ci_low = NA_real_, ci_high = NA_real_
))
}
x_cluster <- x %>% filter(cell %in% cells_cluster) %>% summarise(n = sum(removed, na.rm = TRUE)) %>% pull(n)
# Binomial CI for proportion of removed that are from cluster
bt <- binom.test(x = x_cluster, n = n_removed_sample)
tibble(
method = mname,
x_cluster = x_cluster,
n_removed_sample = n_removed_sample,
ratio   = 100 * x_cluster / n_removed_sample,
ci_low  = 100 * bt$conf.int[1],
ci_high = 100 * bt$conf.int[2]
)
}
stats <- bind_rows(lapply(keep_cols, calc_one)) %>%
mutate(method = factor(method, levels = c("Seurat","scater","miQC","scQCenrich")[c("keep_seurat","keep_scater","keep_miQC","keep_enrich") %in% keep_cols]))
# safety: need scQCenrich for comparisons
if (!("scQCenrich" %in% as.character(stats$method))) {
warning("keep_enrich/scQCenrich not found; p-value comparisons will be skipped.")
}
# ----------------------------
# 3) Pairwise comparisons: scQCenrich vs each other method (prop.test)
# ----------------------------
p_df <- NULL
if ("scQCenrich" %in% as.character(stats$method)) {
sc_row <- stats %>% filter(method == "scQCenrich") %>% slice(1)
others <- stats %>% filter(method != "scQCenrich")
p_df <- others %>%
rowwise() %>%
do({
m <- .
# Build 2x2: [cluster removed / not-cluster removed] for each method
x1 <- sc_row$x_cluster
n1 <- sc_row$n_removed_sample
x2 <- m$x_cluster
n2 <- m$n_removed_sample
if (any(is.na(c(x1, n1, x2, n2))) || any(c(n1, n2) == 0)) {
data.frame(method = m$method, p = NA_real_)
} else {
p <- suppressWarnings(prop.test(x = c(x1, x2), n = c(n1, n2))$p.value)
data.frame(method = m$method, p = p)
}
}) %>%
ungroup() %>%
mutate(p.label = dplyr::case_when(
is.na(p) ~ "ns",
p < 1e-4 ~ "****",
p < 1e-3 ~ "***",
p < 1e-2 ~ "**",
p < 0.05 ~ "*",
TRUE     ~ "ns"
),
group1 = "scQCenrich",
group2 = method)
}
# y positions for brackets (just above the larger of the two bars)
if (!is.null(p_df) && nrow(p_df)) {
y_pos <- stats %>%
filter(method %in% c("scQCenrich", as.character(p_df$method))) %>%
select(method, top = ratio) %>%
tidyr::pivot_wider(names_from = method, values_from = top)
p_df <- p_df %>%
rowwise() %>%
mutate(y.position = 1.05 * max(stats$ratio[stats$method %in% c("scQCenrich", method)], na.rm = TRUE)) %>%
ungroup()
}
# ----------------------------
# 4) Plot: ratio (%) with 95% binomial CI; stars vs scQCenrich
# ----------------------------
p <- ggplot(stats, aes(x = method, y = ratio, fill = method)) +
geom_col(width = 0.65, alpha = 0.95, show.legend = FALSE) +
geom_errorbar(aes(ymin = ci_low, ymax = ci_high), width = 0.16) +
geom_text(aes(label = ifelse(is.finite(ratio),
paste0(sprintf("%.1f", ratio), "%"), "NA")),
vjust = -0.35, size = 3.5) +
scale_y_continuous(labels = function(z) paste0(z, "%"),
expand = expansion(mult = c(0.02, 0.18))) +
labs(x = NULL, y = "Removed in cluster / all removed (%)",
title = "Selectivity of removal for designated cluster",
subtitle = paste0("Clusters: ", paste(target_chr, collapse = ", "))) +
theme_classic(base_size = 12) +
theme(axis.text.x = element_text(angle = 10, hjust = 1))
if (!is.null(p_df) && nrow(p_df) && any(is.finite(p_df$y.position))) {
p <- p + ggpubr::stat_pvalue_manual(
p_df %>% filter(is.finite(y.position)),
label = "p.label",
xmin  = "group1",
xmax  = "group2",
y.position = "y.position",
tip.length = 0.01,
bracket.size = 0.4,
step.increase = 0.05,
inherit.aes = FALSE
)
}
print(p)
# ggsave("removed_selectivity_cluster_ratio_by_method.png", p, width = 8.5, height = 4.0, dpi = 200)
p <- plot_intronic_vs_pctmt(seu)  # replace `seu` with your Seurat object
print(p)
p <- plot_intronic_vs_pctmt(seu, status_col = "keep_miQC", invert = T)  # replace `seu` with your Seurat object
print(p)
p <- plot_intronic_vs_pctmt(seu)  # replace `seu` with your Seurat object
print(p)
p <- plot_intronic_vs_pctmt(seu, status_col = "keep_scater", invert = T)  # replace `seu` with your Seurat object
print(p)
# Example run:
combine_pkg_files(
skip_files = c(
"dev.R", "toy_seu.rda", "README.md",
"testloom.rds", "seurat_std.rds", "PanglaoDB_markers_27_Mar_2020.tsv",
"package_combined.txt"
),
skip_dirs = c(".git", "data", "man", "inst/extdata", "docs", ".github","qc_outputs","benchmarking"),
skip_ext  = c(".rda", ".rds", ".png", ".jpg", ".jpeg", ".pdf", ".html", ".csv", ".tsv",".log",".txt",".Rhistory",".Rproj")
)
document()
install()
library(scQCenrich)
res <- run_qc_pipeline(
obj          = seurat_std_small,                 # normal Seurat for baseline QC
species      = organism,
assay        = "RNA",
method       = "gmm",
# external splicing sources:
spliced_obj        = seurat_sp_small,
spliced_assay      = "spliced",
spliced_layer      = "counts",
unspliced_obj      = seurat_sp_small,
unspliced_assay    = "unspliced",
unspliced_layer    = "counts",
report_html  = TRUE,
report_file  = "qc_outputs/qc_report.html",
debug        = TRUE,
annot_method = "marker_score",
tissue = organ,
marker_method = "findmarkers",
doublets  = "none",
enrichment_plots = F
#qc_strength = "strict"
)
traceback()
document()
install()
library(scQCenrich)
res <- run_qc_pipeline(
obj          = seurat_std_small,                 # normal Seurat for baseline QC
species      = organism,
assay        = "RNA",
method       = "gmm",
# external splicing sources:
spliced_obj        = seurat_sp_small,
spliced_assay      = "spliced",
spliced_layer      = "counts",
unspliced_obj      = seurat_sp_small,
unspliced_assay    = "unspliced",
unspliced_layer    = "counts",
report_html  = TRUE,
report_file  = "qc_outputs/qc_report.html",
debug        = TRUE,
annot_method = "marker_score",
tissue = organ,
marker_method = "findmarkers",
doublets  = "none",
enrichment_plots = F
#qc_strength = "strict"
)
traceback()
document()
install()
library(scQCenrich)
res <- run_qc_pipeline(
obj          = seurat_std_small,                 # normal Seurat for baseline QC
species      = organism,
assay        = "RNA",
method       = "gmm",
# external splicing sources:
spliced_obj        = seurat_sp_small,
spliced_assay      = "spliced",
spliced_layer      = "counts",
unspliced_obj      = seurat_sp_small,
unspliced_assay    = "unspliced",
unspliced_layer    = "counts",
report_html  = TRUE,
report_file  = "qc_outputs/qc_report.html",
debug        = TRUE,
annot_method = "marker_score",
tissue = organ,
marker_method = "findmarkers",
doublets  = "none",
enrichment_plots = F
#qc_strength = "strict"
)
browseURL(res$report)
seu <- res$obj_all
seu$keep_enrich <- seu$qc_status != "remove"
p <- plot_intronic_vs_pctmt(seu)  # replace `seu` with your Seurat object
print(p)
